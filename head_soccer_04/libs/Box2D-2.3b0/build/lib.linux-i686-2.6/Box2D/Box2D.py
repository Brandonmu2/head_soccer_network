# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _Box2D.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Box2D', [dirname(__file__)])
        except ImportError:
            import _Box2D
            return _Box2D
        if fp is not None:
            try:
                _mod = imp.load_module('_Box2D', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Box2D = swig_import_helper()
    del swig_import_helper
else:
    import _Box2D
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


def _dir_filter(self):
    # Using introspection, mimic dir() by adding up all of the __dicts__
    # for the current class and all base classes (type(self).__mro__ returns
    # all of the classes that make it up)
    # Basically filters by:
    # __x__ OK
    # __x bad
    # _classname bad
    def check(s):
        if s.startswith('__'):
            if s.endswith('__'):
                return True
            else:
                return False
        else:
            for typename in typenames:
                if typename in s:
                    return False
            return True
    
    keys=sum([list(c.__dict__.keys()) for c in type(self).__mro__], [])
    typenames=["_%s" % c.__name__ for c in type(self).__mro__]
    ret=[s for s in list(set(keys)) if check(s)]
    ret.sort()
    return ret


def _init_kwargs(self, **kwargs):
    for key, value in kwargs.iteritems():
        try:
            setattr(self, key, value)
        except:
            from sys import exc_info
            ex=exc_info()[1]
            raise ex.__class__('Failed on kwargs for %s.%s: %s' \
                        % (self.__class__.__name__, key, ex))

def _init_jointdef_kwargs(self, bodyA=None, bodyB=None, **kwargs):
    if bodyA is not None or bodyB is not None:
        # Make sure that bodyA and bodyB are defined before the rest
        _init_kwargs(self, bodyA=bodyA, bodyB=bodyB)

    _init_kwargs(self, **kwargs)

_format_recursed=0
def _format_repr(item, props, indent_amount=4, max_level=4, max_str_len=250, max_sub_lines=10):
    global _format_recursed
    _format_recursed+=1
    indent_str=' ' * (_format_recursed*indent_amount) 
    ret=['%s(' % item.__class__.__name__]

    #ret.append(str(_format_recursed))
    if _format_recursed > max_level:
        _format_recursed-=1
        return indent_str + '(*recursion*)'
    
    for prop in props:
        try:
            s=repr(getattr(item, prop))
        except:
            from sys import exc_info
            s='(*repr failed: %s*)' % exc_info()[1]

        if s.count('\n') > max_sub_lines:
            length=0
            for i, line in enumerate(s.split('\n')[:max_sub_lines]):
                length+=len(line)
                if length > max_str_len:
                    ending_delim=''
                    for j in s[::-1]:
                        if j in ')]}':
                            ending_delim+=j
                        else:
                            break
                    ret[-1]+='(...) %s' % ending_delim[::-1]
                    break

                if i==0:
                    ret.append('%s=%s' % (prop, line))
                else:
                    ret.append(line) 
        else:
            if '\n' in s:
                toadd=s.split('\n')
                ret.append('%s=%s' % (prop, toadd[0]))
                ret.extend(toadd[1:])
            else:
                ret.append('%s=%s,' % (prop, s))
    
    separator='\n%s' % indent_str
    _format_recursed-=1
    
    if len(ret) <= 3:
        ret[-1]+=')'
        if _format_recursed==0:
            return ''.join(ret)
        else:
            return [''.join(ret)]
    else:
        ret.append(')')
        return separator.join(ret)


def __jointeq(*args, **kwargs):
  """__jointeq(b2Joint a, b2Joint b) -> bool"""
  return _Box2D.__jointeq(*args, **kwargs)

def __bodyeq(*args, **kwargs):
  """__bodyeq(b2Body a, b2Body b) -> bool"""
  return _Box2D.__bodyeq(*args, **kwargs)

def __shapeeq(*args, **kwargs):
  """__shapeeq(b2Shape a, b2Shape b) -> bool"""
  return _Box2D.__shapeeq(*args, **kwargs)

def __fixtureeq(*args, **kwargs):
  """__fixtureeq(b2Fixture a, b2Fixture b) -> bool"""
  return _Box2D.__fixtureeq(*args, **kwargs)

def __b2ComputeCentroid(*args, **kwargs):
  """__b2ComputeCentroid(b2Vec2 vs, int32 count) -> b2Vec2"""
  return _Box2D.__b2ComputeCentroid(*args, **kwargs)

def b2CheckVertices(*args, **kwargs):
  """b2CheckVertices(b2Vec2 vertices, int32 count, bool additional_checks = True) -> bool"""
  return _Box2D.b2CheckVertices(*args, **kwargs)

def b2CheckPolygon(*args, **kwargs):
  """b2CheckPolygon(b2PolygonShape shape, bool additional_checks = True) -> bool"""
  return _Box2D.b2CheckPolygon(*args, **kwargs)
RAND_LIMIT = _Box2D.RAND_LIMIT
b2_epsilon = 1.192092896e-07

class _indexable_generator(list):
    def __init__(self, iter):
        list.__init__(self)
        self.iter=iter
        self.__full=False
    def __len__(self):
        self.__fill_list__()
        return list.len(self)
    def __iter__(self):
        for item in self.iter:
            self.append(item)
            yield item
        self.__full=True
    def __fill_list__(self):
        for item in self.iter:
            self.append(item)
        self.__full=True
    def __getitem__(self, i):
        """Support indexing positive/negative elements of the generator,
        but no slices. If you want those, use list(generator)"""
        if not self.__full:
            if i < 0:
                self.__fill_list__()
            elif i >= list.__len__(self):
                diff=i-list.__len__(self)+1
                for j in xrange(diff):
                    value=self.iter.next()
                    self.append(value)

        return list.__getitem__(self,i)

def _generator_from_linked_list(first):
    if first:
        one = first
        while one:
            yield one
            one = one.next

def _list_from_linked_list(first):
    if not first:
        return []

    one = first
    lst = []
    while one:
        lst.append(one)
        one = one.next

    # linked lists are stored in reverse order from creation order
    lst.reverse() 
    return lst

# Support using == on bodies, joints, and shapes
def b2ShapeCompare(a, b):
    if not isinstance(a, b2Shape) or not isinstance(b, b2Shape):
        return False
    return __shapeeq(a, b)
def b2BodyCompare(a, b):
    if not isinstance(a, b2Body) or not isinstance(b, b2Body):
        return False
    return __bodyeq(a, b)
def b2JointCompare(a, b):
    if not isinstance(a, b2Joint) or not isinstance(b, b2Joint):
        return False
    return __jointeq(a, b)
def b2FixtureCompare(a, b):
    if not isinstance(a, b2Fixture) or not isinstance(b, b2Fixture):
        return False
    return __fixtureeq(a, b)


def b2Distance(shapeA=None, idxA=0, shapeB=None, idxB=0, transformA=None, transformB=None, useRadii=True):
    """
    Compute the closest points between two shapes.

    Can be called one of two ways:
    + b2Distance(b2DistanceInput) # utilizes the b2DistanceInput structure, where you define your own proxies

    Or utilizing kwargs:
    + b2Distance(shapeA=.., idxA=0, shapeB=.., idxB=0, transformA=.., transformB=.., useRadii=True)
    
    Returns a tuple in the form:
     ((pointAx, pointAy), (pointBx, pointBy), distance, iterations)
    """
    if isinstance(shapeA, b2DistanceInput):
        out = _b2Distance(shapeA)
    else:
        out = _b2Distance(shapeA, idxA, shapeB, idxB, transformA, transformB, useRadii)

    return (tuple(out.pointA), tuple(out.pointB), out.distance, out.iterations)


def b2GetPointStates(*args, **kwargs):
  """
    b2GetPointStates(b2Manifold manifold1, b2Manifold manifold2) -> PyObject

    Compute the point states given two manifolds. The states pertain to the transition from manifold1 to manifold2. So state1 is either persist or remove while state2 is either add or persist.
    """
  return _Box2D.b2GetPointStates(*args, **kwargs)
class b2ContactPoint(object):
    """Proxy of C++ b2ContactPoint class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2ContactPoint_swiginit(self,_Box2D.new_b2ContactPoint())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactPoint
    fixtureA = _swig_property(_Box2D.b2ContactPoint_fixtureA_get, _Box2D.b2ContactPoint_fixtureA_set)
    fixtureB = _swig_property(_Box2D.b2ContactPoint_fixtureB_get, _Box2D.b2ContactPoint_fixtureB_set)
    normal = _swig_property(_Box2D.b2ContactPoint_normal_get, _Box2D.b2ContactPoint_normal_set)
    position = _swig_property(_Box2D.b2ContactPoint_position_get, _Box2D.b2ContactPoint_position_set)
    state = _swig_property(_Box2D.b2ContactPoint_state_get, _Box2D.b2ContactPoint_state_set)
    def __repr__(self):
        return _format_repr(self, ['fixtureA','fixtureB','normal','position','state']) 

b2ContactPoint_swigregister = _Box2D.b2ContactPoint_swigregister
b2ContactPoint_swigregister(b2ContactPoint)
b2Globals = _Box2D.b2Globals

def b2Random(*args):
  """
    b2Random() -> float32
    b2Random(float32 lo, float32 hi) -> float32
    """
  return _Box2D.b2Random(*args)

def _b2Distance(*args):
  """
    _b2Distance(b2Shape shapeA, int idxA, b2Shape shapeB, int idxB, 
        b2Transform transformA, b2Transform transformB, 
        bool useRadii = True) -> b2DistanceOutput
    _b2Distance(b2DistanceInput input) -> b2DistanceOutput
    """
  return _Box2D._b2Distance(*args)

def b2TimeOfImpact(shapeA=None, idxA=0, shapeB=None, idxB=0, sweepA=None, sweepB=None, tMax=0.0):
    """
    Compute the upper bound on time before two shapes penetrate. Time is represented as
    a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
    non-tunneling collision. If you change the time interval, you should call this function
    again.
    Note: use b2Distance to compute the contact point and normal at the time of impact.
    
    Can be called one of several ways:
    + b2TimeOfImpact(b2TOIInput) # utilizes the b2TOIInput structure, where you define your own proxies

    Or utilizing kwargs:
    + b2TimeOfImpact(shapeA=a, shapeB=b, idxA=0, idxB=0, sweepA=sa, sweepB=sb, tMax=t)
    Where idxA and idxB are optional and used only if the shapes are loops (they indicate which section to use.)
    sweep[A,B] are of type b2Sweep.

    Returns a tuple in the form:
    (output state, time of impact)

    Where output state is in b2TOIOutput.[
            e_unknown, 
            e_failed,
            e_overlapped,
            e_touching,
            e_separated ]
    """

    if isinstance(shapeA, b2TOIInput):
        toi_input = shapeA
        out = _b2TimeOfImpact(toi_input)
    else:
        out = _b2TimeOfImpact(shapeA, idxA, shapeB, idxB, sweepA, sweepB, tMax)

    return (out.state, out.t)

class _b2Vec2Array(object):
    """Proxy of C++ _b2Vec2Array class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, size_t nelements) -> _b2Vec2Array"""
        _Box2D._b2Vec2Array_swiginit(self,_Box2D.new__b2Vec2Array(*args, **kwargs))
    __swig_destroy__ = _Box2D.delete__b2Vec2Array
    def __getitem__(self, *args, **kwargs):
        """__getitem__(self, size_t index) -> b2Vec2"""
        return _Box2D._b2Vec2Array___getitem__(self, *args, **kwargs)

    def __setitem__(self, *args, **kwargs):
        """__setitem__(self, size_t index, b2Vec2 value)"""
        return _Box2D._b2Vec2Array___setitem__(self, *args, **kwargs)

    def cast(self):
        """cast(self) -> b2Vec2"""
        return _Box2D._b2Vec2Array_cast(self)

    def frompointer(*args, **kwargs):
        """frompointer(b2Vec2 t) -> _b2Vec2Array"""
        return _Box2D._b2Vec2Array_frompointer(*args, **kwargs)

    frompointer = staticmethod(frompointer)
_b2Vec2Array.__getitem__ = new_instancemethod(_Box2D._b2Vec2Array___getitem__,None,_b2Vec2Array)
_b2Vec2Array.__setitem__ = new_instancemethod(_Box2D._b2Vec2Array___setitem__,None,_b2Vec2Array)
_b2Vec2Array.cast = new_instancemethod(_Box2D._b2Vec2Array_cast,None,_b2Vec2Array)
_b2Vec2Array_swigregister = _Box2D._b2Vec2Array_swigregister
_b2Vec2Array_swigregister(_b2Vec2Array)

def _b2TimeOfImpact(*args):
  """
    _b2TimeOfImpact(b2Shape shapeA, int idxA, b2Shape shapeB, int idxB, 
        b2Sweep sweepA, b2Sweep sweepB, float32 tMax) -> b2TOIOutput
    _b2TimeOfImpact(b2TOIInput input) -> b2TOIOutput
    """
  return _Box2D._b2TimeOfImpact(*args)

def _b2Vec2Array_frompointer(*args, **kwargs):
  """_b2Vec2Array_frompointer(b2Vec2 t) -> _b2Vec2Array"""
  return _Box2D._b2Vec2Array_frompointer(*args, **kwargs)

e_convertVertices = _Box2D.e_convertVertices
class b2DrawExtended(object):
    """Proxy of C++ b2DrawExtended class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    convertVertices = _swig_property(_Box2D.b2DrawExtended_convertVertices_get, _Box2D.b2DrawExtended_convertVertices_set)
    center = _swig_property(_Box2D.b2DrawExtended_center_get, _Box2D.b2DrawExtended_center_set)
    offset = _swig_property(_Box2D.b2DrawExtended_offset_get, _Box2D.b2DrawExtended_offset_set)
    zoom = _swig_property(_Box2D.b2DrawExtended_zoom_get, _Box2D.b2DrawExtended_zoom_set)
    screenSize = _swig_property(_Box2D.b2DrawExtended_screenSize_get, _Box2D.b2DrawExtended_screenSize_set)
    flipY = _swig_property(_Box2D.b2DrawExtended_flipY_get, _Box2D.b2DrawExtended_flipY_set)
    flipX = _swig_property(_Box2D.b2DrawExtended_flipX_get, _Box2D.b2DrawExtended_flipX_set)
    def __Convert(self, *args, **kwargs):
        """__Convert(self, b2Vec2 verts, int32 vertexCount) -> PyObject"""
        return _Box2D.b2DrawExtended___Convert(self, *args, **kwargs)

    def to_screen(self, *args, **kwargs):
        """to_screen(self, b2Vec2 point) -> PyObject"""
        return _Box2D.b2DrawExtended_to_screen(self, *args, **kwargs)

    def DrawPolygon(self, *args, **kwargs):
        """
        DrawPolygon(self, b2Vec2 conv_vertices, int32 vertexCount, b2Color color)

        Draw a closed polygon provided in CCW order.
        """
        return _Box2D.b2DrawExtended_DrawPolygon(self, *args, **kwargs)

    def DrawSolidPolygon(self, *args, **kwargs):
        """
        DrawSolidPolygon(self, b2Vec2 conv_vertices, int32 vertexCount, b2Color color)

        Draw a solid closed polygon provided in CCW order.
        """
        return _Box2D.b2DrawExtended_DrawSolidPolygon(self, *args, **kwargs)

    def DrawCircle(self, *args, **kwargs):
        """
        DrawCircle(self, b2Vec2 conv_p1, float32 radius, b2Color color)

        Draw a circle.
        """
        return _Box2D.b2DrawExtended_DrawCircle(self, *args, **kwargs)

    def DrawSolidCircle(self, *args, **kwargs):
        """
        DrawSolidCircle(self, b2Vec2 conv_p1, float32 radius, b2Vec2 axis, b2Color color)

        Draw a solid circle.
        """
        return _Box2D.b2DrawExtended_DrawSolidCircle(self, *args, **kwargs)

    def DrawSegment(self, *args, **kwargs):
        """
        DrawSegment(self, b2Vec2 conv_p1, b2Vec2 conv_p2, b2Color color)

        Draw a line segment.
        """
        return _Box2D.b2DrawExtended_DrawSegment(self, *args, **kwargs)

    def DrawTransform(self, *args, **kwargs):
        """
        DrawTransform(self, b2Transform xf)

        Draw a transform. Choose your own length scale.

        Parameters:
        -----------

        xf: 
        a transform.
        """
        return _Box2D.b2DrawExtended_DrawTransform(self, *args, **kwargs)

    def __SetFlags(self, *args, **kwargs):
        """__SetFlags(self, uint32 flags)"""
        return _Box2D.b2DrawExtended___SetFlags(self, *args, **kwargs)

    __swig_destroy__ = _Box2D.delete_b2DrawExtended
    def __init__(self, **kwargs):
        if self.__class__ == b2DrawExtended:
            _self = None
        else:
            _self = self
        _Box2D.b2DrawExtended_swiginit(self,_Box2D.new_b2DrawExtended(_self, ))
        _init_kwargs(self, **kwargs)


    def __repr__(self):
        return _format_repr(self, ['center','convertVertices','flags','flipX','flipY','offset','screenSize','zoom']) 

    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2DrawExtended(self)
        return weakref_proxy(self)
b2DrawExtended.__Convert = new_instancemethod(_Box2D.b2DrawExtended___Convert,None,b2DrawExtended)
b2DrawExtended.to_screen = new_instancemethod(_Box2D.b2DrawExtended_to_screen,None,b2DrawExtended)
b2DrawExtended.DrawPolygon = new_instancemethod(_Box2D.b2DrawExtended_DrawPolygon,None,b2DrawExtended)
b2DrawExtended.DrawSolidPolygon = new_instancemethod(_Box2D.b2DrawExtended_DrawSolidPolygon,None,b2DrawExtended)
b2DrawExtended.DrawCircle = new_instancemethod(_Box2D.b2DrawExtended_DrawCircle,None,b2DrawExtended)
b2DrawExtended.DrawSolidCircle = new_instancemethod(_Box2D.b2DrawExtended_DrawSolidCircle,None,b2DrawExtended)
b2DrawExtended.DrawSegment = new_instancemethod(_Box2D.b2DrawExtended_DrawSegment,None,b2DrawExtended)
b2DrawExtended.DrawTransform = new_instancemethod(_Box2D.b2DrawExtended_DrawTransform,None,b2DrawExtended)
b2DrawExtended.__SetFlags = new_instancemethod(_Box2D.b2DrawExtended___SetFlags,None,b2DrawExtended)
b2DrawExtended_swigregister = _Box2D.b2DrawExtended_swigregister
b2DrawExtended_swigregister(b2DrawExtended)

# Backward-compatibility 
b2LoopShape = b2ChainShape

# Initialize the alternative namespace b2.*, and clean-up the
# dir listing of Box2D by removing *_swigregister.
#
# To see what this is, try import Box2D; print(dir(Box2D.b2))
from sys import version_info
if version_info >= (2, 5):
    from . import b2
else:
    import b2
del locals()['version_info']

s=None
to_remove=[]
for s in locals():
    if s.endswith('_swigregister'):
        to_remove.append(s)
    elif s!='b2' and s.startswith('b2'):
        if s[2]=='_': # Covers b2_*
            setattr(b2, s[3].lower() + s[4:], locals()[s])
        else: # The other b2*
            if s[3].isupper():
                setattr(b2, s[2:], locals()[s])
            else:
                setattr(b2, s[2].lower() + s[3:], locals()[s])
for s in to_remove:
    del locals()[s]

del locals()['s']
del locals()['to_remove']



